<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ImageForma</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM CDNs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel Standalone for in-browser JSX transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- PDF.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
    <!-- JSZip CDN for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
        // PDF.js workerã®ãƒ‘ã‚¹ã‚’è¨­å®š
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';
    </script>
    <style>
        /* Custom styles for range input thumbs */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3B82F6; /* Blue-500 */
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
            margin-top: -8px; /* Adjust to center thumb vertically */
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3B82F6; /* Blue-500 */
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.3);
        }

        /* Ensure font-sans is applied */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Define the wave jump animation for individual characters */
        @keyframes waveJumpChar {
            0% {
                transform: translateY(0);
            }
            20% { /* Peak of jump */
                transform: translateY(-10px); /* Adjust jump height */
            }
            100% {
                transform: translateY(0); /* Return to original position */
            }
        }

        /* Define the jump animation for the emoji */
        @keyframes emojiJump {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-8px); /* Adjust height of jump */
            }
        }

        /* Apply the animation on hover to the emoji */
        .emoji-jump:hover {
            animation: emojiJump 0.5s ease-in-out;
        }

        /* Apply the wave animation to characters within the container on hover */
        .wave-char {
            display: inline-block; /* Essential for transform to work on span */
            animation-timing-function: ease-in-out;
            animation-fill-mode: both; /* Keep the final state of the animation */
        }

        .wave-container:hover .wave-char {
            animation: waveJumpChar 0.5s ease-in-out; /* 'infinite' ã‚’å‰Šé™¤ã—ã¦1å›ã®ã¿å®Ÿè¡Œ */
            animation-delay: calc(var(--i) * 0.05s); /* Adjust delay per character */
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-100 to-purple-200 flex items-center justify-center p-4">
    <div id="root"></div>

    <script type="text/babel">
        // Reactã®ãƒ•ãƒƒã‚¯ã¨ReactDOMã®createRootã‚’windowã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ç›´æ¥å–å¾—
        const { useState, useRef, useEffect, useCallback } = window.React;
        const { createRoot } = window.ReactDOM;

        // Main App component
        const App = () => {
            // State variables for application data and UI
            const [selectedFiles, setSelectedFiles] = useState([]); // Stores files selected by the user, now including thumbnail URLs and original dimensions
            const [convertedImages, setConvertedImages] = useState([]); // Stores URLs of converted images
            const [outputFormat, setOutputFormat] = useState('jpeg'); // 'jpeg', 'png', or 'webp'
            const [resizeWidth, setResizeWidth] = useState(''); // Desired width for resizing
            const [resizeHeight, setResizeHeight] = useState(''); // Desired height for resizing
            const [maintainAspectRatio, setMaintainAspectRatio] = useState(true); // Flag to maintain aspect ratio during resize
            const [compressionQuality, setCompressionQuality] = useState(0.8); // JPG/WebP compression quality (0 to 1)
            const [watermarkText, setWatermarkText] = useState(''); // Text for the watermark
            const [watermarkPosition, setWatermarkPosition] = useState('bottomRight'); // Position of the watermark
            const [watermarkFontSize, setWatermarkFontSize] = useState(30); // Font size of the watermark
            const [watermarkFontColor, setWatermarkFontColor] = useState('#FFFFFF'); // Font color of the watermark
            const [watermarkOpacity, setWatermarkOpacity] = useState(0.7); // Opacity of the watermark
            const [watermarkFontFamily, setWatermarkFontFamily] = useState('Inter, sans-serif'); // New: Font family for the watermark
            const [fileNamePrefix, setFileNamePrefix] = useState(''); // Prefix for converted file names
            const [fileNameSuffix, setFileNameSuffix] = useState('-converted'); // Suffix for converted file names
            const [isLoading, setIsLoading] = useState(false); // Loading state for conversion process
            const [error, setError] = useState(''); // Error message
            const [isDragOver, setIsDragOver] = useState(false); // State for drag-and-drop visual feedback
            const [showAdvancedOptions, setShowAdvancedOptions] = useState(false); // New state to toggle advanced options visibility
            const [isZipping, setIsZipping] = useState(false); // New state for ZIP generation loading

            const fileInputRef = useRef(null); // Ref for the hidden file input element
            const convertedImagesRef = useRef(null); // Ref for the converted images section
            const watermarkPreviewRef = useRef(null); // Ref for the watermark preview canvas

            // Function to handle file selection from input or drag-and-drop
            const handleFileChange = async (e) => {
                const files = Array.from(e.target.files || e.dataTransfer.files);
                setError(''); // Clear any previous errors

                const newFilesWithThumbnails = [];
                for (const file of files) {
                    if (file.type.startsWith('image/')) {
                        try {
                            const reader = new FileReader();
                            const fileData = await new Promise((resolve, reject) => {
                                reader.onload = (event) => resolve(event.target.result);
                                reader.onerror = (event) => reject(new Error("ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"));
                                reader.readAsDataURL(file);
                            });

                            const img = new Image();
                            const imgLoad = await new Promise((resolve, reject) => {
                                img.onload = () => resolve(img);
                                img.onerror = () => reject(new Error("ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"));
                                img.src = fileData;
                            });

                            newFilesWithThumbnails.push({
                                file: file,
                                thumbnailUrl: fileData,
                                originalWidth: imgLoad.width,
                                originalHeight: imgLoad.height,
                                isPdf: false, // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ãƒ•ãƒ©ã‚°
                            });
                        } catch (err) {
                            console.error("ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆã‚¨ãƒ©ãƒ¼:", err);
                            newFilesWithThumbnails.push({
                                file: file,
                                thumbnailUrl: null,
                                originalWidth: null,
                                originalHeight: null,
                                isPdf: false,
                            });
                            setError(`ä¸€éƒ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${file.name}`);
                        }
                    } else if (file.type === 'application/pdf') {
                        try {
                            const reader = new FileReader();
                            const arrayBuffer = await new Promise((resolve, reject) => {
                                reader.onload = (event) => resolve(event.target.result);
                                reader.onerror = (event) => reject(new Error("PDFãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚"));
                                reader.readAsArrayBuffer(file);
                            });

                            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                            const page = await pdf.getPage(1); // æœ€åˆã®ãƒšãƒ¼ã‚¸ã‚’ã‚µãƒ ãƒã‚¤ãƒ«ã¨ã—ã¦ä½¿ç”¨

                            const viewport = page.getViewport({ scale: 1 });
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            // ã‚µãƒ ãƒã‚¤ãƒ«ç”¨ã«ã‚µã‚¤ã‚ºã‚’èª¿æ•´
                            const thumbnailScale = Math.min(200 / viewport.width, 200 / viewport.height);
                            const scaledViewport = page.getViewport({ scale: thumbnailScale });

                            canvas.width = scaledViewport.width;
                            canvas.height = scaledViewport.height;

                            // PDFã‚µãƒ ãƒã‚¤ãƒ«ã®èƒŒæ™¯ã‚’ç™½ã§å¡—ã‚Šã¤ã¶ã™
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            await page.render({ canvasContext: ctx, viewport: scaledViewport }).promise;

                            newFilesWithThumbnails.push({
                                file: file,
                                thumbnailUrl: canvas.toDataURL('image/png'), // PDFã‚µãƒ ãƒã‚¤ãƒ«ã¯PNGã§
                                originalWidth: viewport.width, // PDFã®å…ƒã®ãƒšãƒ¼ã‚¸ã‚µã‚¤ã‚º
                                originalHeight: viewport.height,
                                isPdf: true, // PDFãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ãƒ•ãƒ©ã‚°
                            });
                        } catch (err) {
                            console.error("PDFã‚µãƒ ãƒã‚¤ãƒ«ç”Ÿæˆã‚¨ãƒ©ãƒ¼:", err);
                            newFilesWithThumbnails.push({
                                file: file,
                                thumbnailUrl: null,
                                originalWidth: null,
                                originalHeight: null,
                                isPdf: true,
                            });
                            setError(`PDFã‚µãƒ ãƒã‚¤ãƒ«ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${file.name}`);
                        }
                    } else {
                        // ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—
                        newFilesWithThumbnails.push({
                            file: file,
                            thumbnailUrl: null,
                            originalWidth: null,
                            originalHeight: null,
                            isPdf: false, // PDFã§ã‚‚ç”»åƒã§ã‚‚ãªã„
                        });
                        setError(`ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã®ãŸã‚ã€${file.name} ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¯è¡¨ç¤ºã•ã‚Œã¾ã›ã‚“ã€‚`);
                    }
                }
                setSelectedFiles(prevFiles => [...prevFiles, ...newFilesWithThumbnails]);
            };

            // Function to remove a file from the selected list
            const removeFile = (index) => {
                setSelectedFiles(prevFiles => prevFiles.filter((_, i) => i !== index));
            };

            // Function to handle drag over event for visual feedback
            const handleDragOver = (e) => {
                e.preventDefault();
                setIsDragOver(true);
            };

            // Function to handle drag leave event
            const handleDragLeave = (e) => {
                e.preventDefault();
                setIsDragOver(false);
            };

            // Function to handle drop event
            const handleDrop = (e) => {
                e.preventDefault();
                setIsDragOver(false);
                handleFileChange(e); // Process dropped files
            };

            // Function to trigger file input click
            const triggerFileInput = () => {
                fileInputRef.current.click();
            };

            // Function to clear all selected files and converted images
            const clearAll = () => {
                setSelectedFiles([]);
                setConvertedImages([]);
                setError('');
                setIsLoading(false);
                setIsZipping(false);
            };

            // Callback to update height when width changes, maintaining aspect ratio
            const handleWidthChange = useCallback((e) => {
                const newWidth = e.target.value;
                setResizeWidth(newWidth);
                // Use the dimensions of the first selected file for aspect ratio calculation
                if (maintainAspectRatio && selectedFiles.length > 0 && selectedFiles[0].originalWidth && newWidth) {
                    const originalWidth = selectedFiles[0].originalWidth;
                    const originalHeight = selectedFiles[0].originalHeight;
                    setResizeHeight(Math.round((newWidth / originalWidth) * originalHeight));
                }
            }, [maintainAspectRatio, selectedFiles]);

            // Callback to update width when height changes, maintaining aspect ratio
            const handleHeightChange = useCallback((e) => {
                const newHeight = e.target.value;
                setResizeHeight(newHeight);
                // Use the dimensions of the first selected file for aspect ratio calculation
                if (maintainAspectRatio && selectedFiles.length > 0 && selectedFiles[0].originalWidth && newHeight) {
                    const originalWidth = selectedFiles[0].originalWidth;
                    const originalHeight = selectedFiles[0].originalHeight;
                    setResizeWidth(Math.round((newHeight / originalHeight) * originalWidth));
                }
            }, [maintainAspectRatio, selectedFiles]);

            // Function to draw watermark on a given canvas context, with optional scaling
            const drawWatermark = (ctx, canvasWidth, canvasHeight, scale = 1) => {
                if (!watermarkText) return; // Don't draw if no text

                ctx.save(); // ç¾åœ¨ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã®çŠ¶æ…‹ã‚’ä¿å­˜

                const scaledFontSize = watermarkFontSize * scale; // Scale font size based on preview scale
                ctx.font = `${scaledFontSize}px ${watermarkFontFamily}`;
                ctx.fillStyle = watermarkFontColor;
                ctx.globalAlpha = watermarkOpacity;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';

                const textMetrics = ctx.measureText(watermarkText);
                const textWidth = textMetrics.width;
                const textHeight = scaledFontSize; // Approximate height

                let x, y;

                // ä½™ç™½ã‚’è€ƒæ…®ã—ãŸä½ç½®è¨ˆç®—
                const paddingX = 10 * scale;
                const paddingY = 10 * scale;

                switch (watermarkPosition) {
                    case 'topLeft':
                        x = paddingX;
                        y = paddingY;
                        break;
                    case 'topRight':
                        x = canvasWidth - textWidth - paddingX;
                        y = paddingY;
                        break;
                    case 'bottomLeft':
                        x = paddingX;
                        y = canvasHeight - textHeight - paddingY;
                        break;
                    case 'bottomRight':
                        x = canvasWidth - textWidth - paddingX;
                        y = canvasHeight - textHeight - paddingY;
                        break;
                    case 'center':
                        x = (canvasWidth - textWidth) / 2;
                        y = (canvasHeight - textHeight) / 2;
                        break;
                    default:
                        x = paddingX;
                        y = paddingY;
                }
                ctx.fillText(watermarkText, x, y);

                ctx.restore(); // ä¿å­˜ã—ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ã®çŠ¶æ…‹ã‚’å¾©å…ƒ
            };

            // Core function to convert images
            const convertImages = async () => {
                if (selectedFiles.length === 0) {
                    setError('å¤‰æ›ã™ã‚‹ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                    return;
                }

                setIsLoading(true);
                setConvertedImages([]); // Clear previous converted images
                setError('');

                const newConvertedImages = [];

                for (const selectedFileItem of selectedFiles) {
                    const file = selectedFileItem.file;

                    try {
                        let itemsToProcess = []; // å¤‰æ›å‡¦ç†ã‚’è¡Œã†ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆç”»åƒã¾ãŸã¯PDFãƒšãƒ¼ã‚¸ï¼‰ã®é…åˆ—

                        if (selectedFileItem.isPdf) {
                            // PDFãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                            const reader = new FileReader();
                            const arrayBuffer = await new Promise((resolve, reject) => {
                                reader.onload = (event) => resolve(event.target.result);
                                reader.onerror = (event) => reject(new Error(`PDFãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${file.name}`));
                                reader.readAsArrayBuffer(file);
                            });

                            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                            const numPages = pdf.numPages;

                            for (let i = 1; i <= numPages; i++) {
                                const page = await pdf.getPage(i);
                                const viewport = page.getViewport({ scale: 1 });

                                itemsToProcess.push({
                                    type: 'pdfPage',
                                    page: page,
                                    originalWidth: viewport.width,
                                    originalHeight: viewport.height,
                                    pageNumber: i,
                                    fileName: file.name,
                                });
                            }
                        } else {
                            // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                            const reader = new FileReader();
                            const fileData = await new Promise((resolve, reject) => {
                                reader.onload = (event) => resolve(event.target.result);
                                reader.onerror = (event) => reject(new Error(`ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${file.name}`));
                                reader.readAsDataURL(file);
                            });

                            const img = new Image();
                            await new Promise((resolve, reject) => {
                                img.onload = resolve;
                                img.onerror = reject;
                                img.src = fileData;
                            });

                            itemsToProcess.push({
                                type: 'image',
                                img: img,
                                originalWidth: img.width,
                                originalHeight: img.height,
                                fileName: file.name,
                            });
                        }

                        // å„ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆç”»åƒã¾ãŸã¯PDFãƒšãƒ¼ã‚¸ï¼‰ã‚’å¤‰æ›
                        for (const item of itemsToProcess) {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');

                            let currentWidth = item.originalWidth;
                            let currentHeight = item.originalHeight;

                            // ãƒªã‚µã‚¤ã‚ºè¨­å®šã®é©ç”¨
                            if (showAdvancedOptions && (resizeWidth || resizeHeight)) {
                                let targetWidth = resizeWidth ? parseInt(resizeWidth, 10) : item.originalWidth;
                                let targetHeight = resizeHeight ? parseInt(resizeHeight, 10) : item.originalHeight;

                                if (maintainAspectRatio) {
                                    if (resizeWidth && !resizeHeight) {
                                        targetHeight = (targetWidth / item.originalWidth) * item.originalHeight;
                                    } else if (resizeHeight && !resizeWidth) {
                                        targetWidth = (targetHeight / item.originalHeight) * item.originalWidth;
                                    }
                                }
                                currentWidth = targetWidth;
                                currentHeight = targetHeight;
                            }

                            canvas.width = currentWidth;
                            canvas.height = currentHeight;

                            // æ˜ç¤ºçš„ã«ã‚­ãƒ£ãƒ³ãƒã‚¹ã®èƒŒæ™¯ã‚’ç™½ã§å¡—ã‚Šã¤ã¶ã™
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            if (item.type === 'image') {
                                ctx.drawImage(item.img, 0, 0, currentWidth, currentHeight);
                            } else if (item.type === 'pdfPage') {
                                const viewport = item.page.getViewport({ scale: currentWidth / item.originalWidth });
                                await item.page.render({ canvasContext: ctx, viewport: viewport }).promise;
                            }

                            // ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒãƒ¼ã‚¯ã®é©ç”¨
                            if (showAdvancedOptions && watermarkText) {
                                drawWatermark(ctx, currentWidth, currentHeight, 1);
                            }

                            // å‡ºåŠ›å½¢å¼ã¨å“è³ªã®æ±ºå®š
                            let mimeType;
                            let quality = showAdvancedOptions ? compressionQuality : 0.8;

                            switch (outputFormat) {
                                case 'jpeg':
                                    mimeType = 'image/jpeg';
                                    break;
                                case 'png':
                                    mimeType = 'image/png';
                                    break; // PNG doesn't use quality parameter
                                case 'webp':
                                    mimeType = 'image/webp';
                                    break;
                                default:
                                    mimeType = 'image/jpeg';
                                    break;
                            }

                            const convertedDataUrl = canvas.toDataURL(mimeType, quality);

                            // æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«åã®æ§‹ç¯‰
                            const originalFileNameWithoutExt = item.fileName.split('.').slice(0, -1).join('.');
                            const pageSuffix = item.type === 'pdfPage' ? `_page${item.pageNumber}` : '';
                            const newFileName = showAdvancedOptions
                                ? `${fileNamePrefix}${originalFileNameWithoutExt}${pageSuffix}${fileNameSuffix}.${outputFormat}`
                                : `${originalFileNameWithoutExt}${pageSuffix}.${outputFormat}`;

                            newConvertedImages.push({
                                name: newFileName,
                                url: convertedDataUrl,
                            });
                        }

                    } catch (err) {
                        console.error('å¤‰æ›ã‚¨ãƒ©ãƒ¼:', err);
                        setError(`ãƒ•ã‚¡ã‚¤ãƒ«ã®å¤‰æ›ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ ${file.name}: ${err.message}`);
                    }
                }
                setConvertedImages(newConvertedImages);
                setIsLoading(false);
            };

            // useEffect to scroll to converted images section when convertedImages state changes
            useEffect(() => {
                if (convertedImages.length > 0 && convertedImagesRef.current) {
                    convertedImagesRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, [convertedImages]); // Dependency array includes convertedImages

            // useEffect for watermark preview
            useEffect(() => {
                const canvas = watermarkPreviewRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous drawing

                if (selectedFiles.length > 0 && showAdvancedOptions && selectedFiles[0].thumbnailUrl) {
                    const img = new Image();
                    img.onload = () => {
                        const originalImgWidth = selectedFiles[0].originalWidth; // å…ƒã®ç”»åƒ/PDFãƒšãƒ¼ã‚¸ã®å¹…
                        const originalImgHeight = selectedFiles[0].originalHeight; // å…ƒã®ç”»åƒ/PDFãƒšãƒ¼ã‚¸ã®é«˜ã•

                        const maxWidth = 300;
                        const maxHeight = 200;
                        let previewWidth = originalImgWidth;
                        let previewHeight = originalImgHeight;
                        let scaleFactor = 1;

                        // Calculate scaling to fit within preview area
                        if (previewWidth > maxWidth || previewHeight > maxHeight) {
                            const widthRatio = maxWidth / previewWidth;
                            const heightRatio = maxHeight / previewHeight;
                            scaleFactor = Math.min(widthRatio, heightRatio);

                            previewWidth = originalImgWidth * scaleFactor;
                            previewHeight = originalImgHeight * scaleFactor;
                        }
                        
                        canvas.width = previewWidth;
                        canvas.height = previewHeight;

                        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚­ãƒ£ãƒ³ãƒã‚¹ã®èƒŒæ™¯ã‚’ç™½ã§å¡—ã‚Šã¤ã¶ã™
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        ctx.drawImage(img, 0, 0, previewWidth, previewHeight);
                        // ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒãƒ¼ã‚¯ã®æç”»ã«å…ƒã®ç”»åƒã®ã‚¹ã‚±ãƒ¼ãƒ«ãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ã‚’æ¸¡ã™
                        drawWatermark(ctx, previewWidth, previewHeight, scaleFactor);
                    };
                    img.onerror = () => {
                        console.error("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
                        // Display a message on canvas if image fails to load
                        ctx.fillStyle = '#FF0000';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center'; // Center the error text
                        ctx.textBaseline = 'middle';
                        canvas.width = 300; // Set default preview canvas size
                        canvas.height = 200;
                        ctx.fillText('ç”»åƒèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼', canvas.width / 2, canvas.height / 2);
                    };
                    img.src = selectedFiles[0].thumbnailUrl;
                } else if (showAdvancedOptions && selectedFiles.length === 0) {
                    // Display a prompt if no image is selected for preview
                    ctx.fillStyle = '#6B7280'; /* gray-500 */
                    ctx.font = '16px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    canvas.width = 300; // Set a default preview canvas size when no image
                    canvas.height = 200;
                    // Split the message into two lines
                    const line1 = 'ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦';
                    const line2 = 'ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒãƒ¼ã‚¯ã‚’ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼';
                    const lineHeight = 20; // Adjust as needed
                    ctx.fillText(line1, canvas.width / 2, canvas.height / 2 - lineHeight / 2);
                    ctx.fillText(line2, canvas.width / 2, canvas.height / 2 + lineHeight / 2);
                } else if (showAdvancedOptions && selectedFiles.length > 0 && !selectedFiles[0].thumbnailUrl) {
                     // Display a message if image is not a standard image type for preview
                    ctx.fillStyle = '#6B7280'; /* gray-500 */
                    ctx.font = '16px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    canvas.width = 300; // Set a default preview canvas size
                    canvas.height = 200;
                    ctx.fillText('ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“', canvas.width / 2, canvas.height / 2);
                }
            }, [selectedFiles, watermarkText, watermarkPosition, watermarkFontSize, watermarkFontColor, watermarkOpacity, watermarkFontFamily, showAdvancedOptions]);


            // Function to download a single converted image
            const downloadImage = (image) => {
                const link = document.createElement('a');
                link.href = image.url;
                link.download = image.name;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            // Function to download all converted images as a ZIP
            const downloadAllImages = async () => {
                if (convertedImages.length === 0) {
                    setError('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹å¤‰æ›æ¸ˆã¿ç”»åƒãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
                    return;
                }

                setIsZipping(true);
                setError('');

                const zip = new JSZip();
                
                // Get current date and time for a unique filename
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const dateTimeStamp = `${year}${month}${day}_${hours}${minutes}${seconds}`;

                // Create a descriptive folder name inside the ZIP
                const folderName = `ImageForma_Converted_Images_${dateTimeStamp}`;
                const imgFolder = zip.folder(folderName);

                for (const image of convertedImages) {
                    try {
                        // Extract Base64 data from Data URL
                        const base64Data = image.url.split(',')[1];
                        // Add file to ZIP
                        imgFolder.file(image.name, base64Data, { base64: true });
                    } catch (err) {
                        console.error(`ZIPã¸ã®ãƒ•ã‚¡ã‚¤ãƒ«è¿½åŠ ã‚¨ãƒ©ãƒ¼ ${image.name}:`, err);
                        setError(`ZIPãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®è¿½åŠ ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${image.name}`);
                        setIsZipping(false);
                        return;
                    }
                }

                try {
                    // Generate the ZIP file and trigger download
                    const content = await zip.generateAsync({ type: "blob" });
                    const zipFileName = `${folderName}.zip`; // Use the same descriptive name for the ZIP file
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(content);
                    link.download = zipFileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href); // Release object URL
                } catch (err) {
                    console.error('ZIPãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', err);
                    setError(`ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${err.message}`);
                } finally {
                    setIsZipping(false);
                }
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-100 to-purple-200 flex items-center justify-center p-4 font-sans">
                    <div className="bg-white shadow-2xl rounded-3xl p-8 w-full max-w-4xl transform transition-all duration-300 hover:scale-[1.005]">
                        <h1 className="text-4xl font-extrabold text-center text-gray-800 mb-2 tracking-tight drop-shadow-md">
                            <span className="inline-block wave-container">
                                {'ImageForma'.split('').map((char, index) => (
                                    <span key={index} className="wave-char" style={{'--i': index}}>
                                        {char}
                                    </span>
                                ))}
                            </span>{' '} {/* Add a space here to separate text and emoji */}
                            <span className="inline-block emoji-jump">ğŸ–¼ï¸</span>
                        </h1>
                        <p className="text-center text-gray-600 text-sm mb-10">
                            ç”»åƒã‚’ç°¡å˜ã«å¤‰æ›ï¼ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒãƒ¼ã‚¯è¿½åŠ ãªã©é«˜åº¦ãªè¨­å®šã‚‚å¯èƒ½
                        </p>

                        {/* File Input Section */}
                        <div
                            className={`border-4 border-dashed rounded-2xl p-10 mb-8 text-center transition-all duration-300
                                ${isDragOver ? 'border-blue-500 bg-blue-50 shadow-inner' : 'border-indigo-300 bg-indigo-50 shadow-sm'}`}
                            onDragOver={handleDragOver}
                            onDragLeave={handleDragLeave}
                            onDrop={handleDrop}
                        >
                            <input
                                type="file"
                                multiple
                                accept="image/*, application/pdf"
                                onChange={handleFileChange}
                                ref={fileInputRef}
                                className="hidden"
                            />
                            <p className="text-gray-700 text-lg mb-6 flex items-center justify-center">
                                ã“ã“ã«ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã‹
                                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="w-8 h-8 ml-2 text-gray-500">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l3.75 3.75M12 9.75L8.25 13.5M7.21 18C4.94 18 3 16.06 3 13.79C3 11.52 4.94 9.58 7.21 9.58C7.62 6.78 10.04 4.5 12.98 4.5C16.03 4.5 18.5 7.02 18.5 10.07C20.77 10.07 22.71 12.01 22.71 14.28C22.71 16.55 20.77 18.49 18.5 18.49H7.21Z"/>
                                </svg>
                            </p>
                            <button
                                onClick={triggerFileInput}
                                className="px-8 py-4 bg-gradient-to-r from-blue-600 to-purple-600 text-white font-bold text-xl rounded-full shadow-lg
                                           hover:from-blue-700 hover:to-purple-700 focus:outline-none focus:ring-4 focus:ring-blue-300 focus:ring-offset-2
                                           transition-all transform hover:scale-105 active:scale-95"
                            >
                                ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
                            </button>
                        </div>

                        {/* Selected Files Display */}
                        {selectedFiles.length > 0 && (
                            <div className="mb-8 bg-gray-50 p-6 rounded-2xl border border-gray-200 shadow-inner">
                                <h2 className="text-2xl font-bold text-gray-800 mb-4">é¸æŠä¸­ã®ãƒ•ã‚¡ã‚¤ãƒ« ({selectedFiles.length}ä»¶)</h2>
                                <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 max-h-64 overflow-y-auto pr-2">
                                    {selectedFiles.map((item, index) => (
                                        <div key={index} className="flex flex-col items-center bg-white p-3 rounded-lg shadow-md border border-gray-100 relative group">
                                            {item.thumbnailUrl ? (
                                                <img
                                                    src={item.thumbnailUrl}
                                                    alt={item.file.name}
                                                    className="w-24 h-24 object-contain rounded-md mb-2 border border-gray-200"
                                                />
                                            ) : (
                                                <div className="w-24 h-24 flex items-center justify-center bg-gray-200 rounded-md mb-2 text-gray-500 text-center text-sm">
                                                    ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãªã—<br/>(ç”»åƒä»¥å¤–)
                                                </div>
                                            )}
                                            <span className="text-gray-800 text-xs font-medium text-center w-full truncate px-1">{item.file.name}</span>
                                            <button
                                                onClick={() => removeFile(index)}
                                                className="absolute top-1 right-1 text-red-500 bg-white rounded-full p-1 shadow-md opacity-0 group-hover:opacity-100 transition-opacity hover:text-red-700 hover:scale-110"
                                                title="ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤"
                                            >
                                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                    <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clipRule="evenodd" />
                                                </svg>
                                            </button>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Output Format */}
                        <div className="bg-gray-50 p-6 rounded-2xl border border-gray-200 shadow-sm mb-8">
                            <label htmlFor="outputFormat" className="block text-gray-700 text-xl font-bold mb-3">
                                å‡ºåŠ›å½¢å¼
                            </label>
                            <select
                                id="outputFormat"
                                value={outputFormat}
                                onChange={(e) => setOutputFormat(e.target.value)}
                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-lg shadow-sm"
                            >
                                <option value="jpeg">JPG</option>
                                <option value="png">PNG</option>
                                <option value="webp">WebP</option> {/* Added WebP option */}
                            </select>
                        </div>

                        {/* Toggle Advanced Options Button */}
                        <div className="text-center mb-8">
                            <button
                                onClick={() => setShowAdvancedOptions(!showAdvancedOptions)}
                                className="px-8 py-4 bg-gradient-to-r from-gray-700 to-gray-900 text-white font-bold text-lg rounded-full shadow-lg
                                   hover:from-gray-800 hover:to-black focus:outline-none focus:ring-4 focus:ring-gray-400 focus:ring-offset-2
                                   transition-all transform hover:scale-105 active:scale-95 flex items-center justify-center mx-auto"
                            >
                                {showAdvancedOptions ? 'é«˜åº¦ãªè¨­å®šã‚’éš ã™' : 'é«˜åº¦ãªè¨­å®šã‚’è¡¨ç¤º'}
                                <svg
                                    className={`ml-3 h-6 w-6 transform transition-transform duration-300 ${showAdvancedOptions ? 'rotate-180' : ''}`}
                                    xmlns="http://www.w3.org/2000/svg"
                                    fill="none"
                                    viewBox="0 0 24 24"
                                    stroke="currentColor"
                                >
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7" />
                                </svg>
                            </button>
                        </div>

                        {/* Advanced Options Section (Conditionally Rendered) */}
                        {showAdvancedOptions && (
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8 transition-all duration-500 ease-in-out transform scale-y-100 origin-top">
                                {/* Resize Options */}
                                <div className="bg-gray-50 p-6 rounded-2xl border border-gray-200 shadow-sm">
                                    <label className="block text-gray-700 text-xl font-bold mb-3">
                                        ãƒªã‚µã‚¤ã‚º (px)
                                    </label>
                                    <div className="flex items-center space-x-4 mb-3">
                                        <input
                                            type="number"
                                            placeholder="å¹…"
                                            value={resizeWidth}
                                            onChange={handleWidthChange}
                                            className="w-1/2 p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-lg shadow-sm"
                                        />
                                        <span className="text-gray-600 text-xl font-semibold">x</span>
                                        <input
                                            type="number"
                                            placeholder="é«˜ã•"
                                            value={resizeHeight}
                                            onChange={handleHeightChange}
                                            className="w-1/2 p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-lg shadow-sm"
                                        />
                                    </div>
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            id="maintainAspectRatio"
                                            checked={maintainAspectRatio}
                                            onChange={(e) => setMaintainAspectRatio(e.target.checked)}
                                            className="h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500 cursor-pointer"
                                        />
                                        <label htmlFor="maintainAspectRatio" className="ml-3 text-gray-700 text-base cursor-pointer">
                                            ç¸¦æ¨ªæ¯”ã‚’ç¶­æŒ
                                        </label>
                                    </div>
                                </div>

                                {/* Compression Quality (JPG/WebP only) */}
                                {(outputFormat === 'jpeg' || outputFormat === 'webp') && (
                                    <div className="bg-gray-50 p-6 rounded-2xl border border-gray-200 shadow-sm">
                                        <label htmlFor="compressionQuality" className="block text-gray-700 text-xl font-bold mb-3">
                                            åœ§ç¸®å“è³ª ({outputFormat.toUpperCase()})
                                        </label>
                                        <input
                                            type="range"
                                            id="compressionQuality"
                                            min="0"
                                            max="1"
                                            step="0.01"
                                            value={compressionQuality}
                                            onChange={(e) => setCompressionQuality(parseFloat(e.target.value))}
                                            className="w-full h-3 bg-blue-200 rounded-lg appearance-none cursor-pointer thumb-blue-500"
                                            style={{
                                                background: `linear-gradient(to right, #3B82F6 0%, #3B82F6 ${compressionQuality * 100}%, #D1D5DB ${compressionQuality * 100}%, #D1D5DB 100%)`
                                            }}
                                        />
                                        <span className="text-base text-gray-600 mt-2 block">{Math.round(compressionQuality * 100)}%</span>
                                    </div>
                                )}

                                {/* Watermark Options */}
                                <div className="bg-gray-50 p-6 rounded-2xl border border-gray-200 shadow-sm">
                                    <label htmlFor="watermarkText" className="block text-gray-700 text-xl font-bold mb-3">
                                        ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒãƒ¼ã‚¯
                                    </label>
                                    <input
                                        type="text"
                                        id="watermarkText"
                                        placeholder="ã‚¦ã‚©ãƒ¼ã‚¿ãƒ¼ãƒãƒ¼ã‚¯ã®ãƒ†ã‚­ã‚¹ãƒˆ"
                                        value={watermarkText}
                                        onChange={(e) => setWatermarkText(e.target.value)}
                                        className="w-full p-3 border border-gray-300 rounded-lg mb-3 focus:ring-blue-500 focus:border-blue-500 text-lg shadow-sm"
                                    />
                                    <div className="grid grid-cols-2 gap-4 mb-3">
                                        <div>
                                            <label htmlFor="watermarkFontSize" className="block text-gray-600 text-sm mb-1">ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º</label>
                                            <input
                                                type="number"
                                                id="watermarkFontSize"
                                                value={watermarkFontSize}
                                                onChange={(e) => setWatermarkFontSize(parseInt(e.target.value, 10))}
                                                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-lg shadow-sm"
                                            />
                                        </div>
                                        <div>
                                            <label htmlFor="watermarkFontColor" className="block text-gray-600 text-sm mb-1">è‰²</label>
                                            <input
                                                type="color"
                                                id="watermarkFontColor"
                                                value={watermarkFontColor}
                                                onChange={(e) => setWatermarkFontColor(e.target.value)}
                                                className="w-full h-12 border border-gray-300 rounded-lg cursor-pointer shadow-sm"
                                            />
                                        </div>
                                    </div>
                                    <div className="mb-3">
                                        <label htmlFor="watermarkOpacity" className="block text-gray-600 text-sm mb-1">ä¸é€æ˜åº¦</label>
                                        <input
                                            type="range"
                                            id="watermarkOpacity"
                                            min="0"
                                            max="1"
                                            step="0.01"
                                            value={watermarkOpacity}
                                            onChange={(e) => setWatermarkOpacity(parseFloat(e.target.value))}
                                            className="w-full h-3 bg-blue-200 rounded-lg appearance-none cursor-pointer thumb-blue-500"
                                            style={{
                                                background: `linear-gradient(to right, #3B82F6 0%, #3B82F6 ${watermarkOpacity * 100}%, #D1D5DB ${watermarkOpacity * 100}%, #D1D5DB 100%)`
                                            }}
                                        />
                                        <span className="text-base text-gray-600 mt-2 block">{Math.round(watermarkOpacity * 100)}%</span>
                                    </div>
                                    {/* Watermark Font Family Selection */}
                                    <div className="mb-3">
                                        <label htmlFor="watermarkFontFamily" className="block text-gray-600 text-sm mb-1">ãƒ•ã‚©ãƒ³ãƒˆ</label>
                                        <select
                                            id="watermarkFontFamily"
                                            value={watermarkFontFamily}
                                            onChange={(e) => setWatermarkFontFamily(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-lg shadow-sm"
                                        >
                                            <option value="Inter, sans-serif">Inter (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)</option>
                                            <option value="Arial, sans-serif">Arial</option>
                                            <option value="Helvetica, sans-serif">Helvetica</option>
                                            <option value="Verdana, sans-serif">Verdana</option>
                                            <option value="Georgia, serif">Georgia</option>
                                            <option value="Times New Roman, serif">Times New Roman</option>
                                            <option value="Courier New, monospace">Courier New</option>
                                        </select>
                                    </div>
                                    {/* Watermark Position Selection */}
                                    <div className="mb-4">
                                        <label htmlFor="watermarkPosition" className="block text-gray-600 text-sm mb-1">ä½ç½®</label>
                                        <select
                                            id="watermarkPosition"
                                            value={watermarkPosition}
                                            onChange={(e) => setWatermarkPosition(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-lg shadow-sm"
                                        >
                                            <option value="topLeft">å·¦ä¸Š</option>
                                            <option value="topRight">å³ä¸Š</option>
                                            <option value="bottomLeft">å·¦ä¸‹</option>
                                            <option value="bottomRight">å³ä¸‹</option>
                                            <option value="center">ä¸­å¤®</option>
                                        </select>
                                    </div>

                                    {/* Watermark Preview Canvas */}
                                    <div className="w-full bg-gray-100 rounded-lg overflow-hidden border border-gray-200 shadow-inner flex items-center justify-center" style={{ minHeight: '200px' }}>
                                        <canvas ref={watermarkPreviewRef} className="max-w-full max-h-full block"></canvas>
                                    </div>
                                </div>

                                {/* File Naming Options */}
                                <div className="bg-gray-50 p-6 rounded-2xl border border-gray-200 shadow-sm">
                                    <label htmlFor="fileNamePrefix" className="block text-gray-700 text-xl font-bold mb-3">
                                        ãƒ•ã‚¡ã‚¤ãƒ«åè¨­å®š
                                    </label>
                                    <div className="mb-3">
                                        <label htmlFor="fileNamePrefix" className="block text-gray-600 text-sm mb-1">ãƒ•ã‚¡ã‚¤ãƒ«åã®å…ˆé ­ã«è¿½åŠ </label>
                                        <input
                                            type="text"
                                            id="fileNamePrefix"
                                            placeholder="ä¾‹: my-image-"
                                            value={fileNamePrefix}
                                            onChange={(e) => setFileNamePrefix(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-lg shadow-sm"
                                        />
                                    </div>
                                    <div>
                                        <label htmlFor="fileNameSuffix" className="block text-gray-600 text-sm mb-1">ãƒ•ã‚¡ã‚¤ãƒ«åã®æœ«å°¾ã«è¿½åŠ </label>
                                        <input
                                            type="text"
                                            id="fileNameSuffix"
                                            placeholder="ä¾‹: -edited"
                                            value={fileNameSuffix}
                                            onChange={(e) => setFileNameSuffix(e.target.value)}
                                            className="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-lg shadow-sm"
                                        />
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Action Buttons */}
                        <div className="flex justify-center space-x-6 mb-8 mt-10">
                            <button
                                onClick={convertImages}
                                disabled={selectedFiles.length === 0 || isLoading}
                                className={`px-10 py-5 rounded-full text-white font-bold text-2xl shadow-xl
                                           ${selectedFiles.length === 0 || isLoading ? 'bg-gray-400 cursor-not-allowed' : 'bg-gradient-to-r from-green-500 to-teal-600 hover:from-green-600 hover:to-teal-700 focus:outline-none focus:ring-4 focus:ring-green-300 focus:ring-offset-2 transition-all transform hover:scale-105 active:scale-95'}`}
                            >
                                {isLoading ? (
                                    <div className="flex items-center">
                                        <svg className="animate-spin -ml-1 mr-3 h-7 w-7 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                        </svg>
                                        å¤‰æ›ä¸­...
                                    </div>
                                ) : (
                                    'ç”»åƒã‚’å¤‰æ›'
                                )}
                            </button>
                            <button
                                onClick={clearAll}
                                className="px-8 py-4 bg-gradient-to-r from-red-500 to-pink-600 text-white font-semibold rounded-full shadow-lg
                                           hover:from-red-600 hover:to-pink-700 focus:outline-none focus:ring-4 focus:ring-red-300 focus:ring-offset-2
                                           transition-all transform hover:scale-105 active:scale-95"
                            >
                                ã™ã¹ã¦ã‚¯ãƒªã‚¢
                            </button>
                        </div>

                        {/* Error Message */}
                        {error && (
                            <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg relative mb-8 shadow-md" role="alert">
                                <p className="font-bold">ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:</p>
                                <p className="text-sm">{error}</p>
                            </div>
                        )}

                        {/* Converted Images Display */}
                        {convertedImages.length > 0 && (
                            <div ref={convertedImagesRef} className="mt-10 bg-blue-50 p-8 rounded-2xl border border-blue-200 shadow-xl">
                                <h2 className="text-3xl font-bold text-blue-800 mb-6 text-center">å¤‰æ›æ¸ˆã¿ç”»åƒ</h2>
                                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                                    {convertedImages.map((image, index) => (
                                        <div key={index} className="bg-white rounded-xl shadow-lg overflow-hidden border border-gray-200 transform transition-all duration-200 hover:scale-[1.02]">
                                            <img
                                                src={image.url}
                                                alt={image.name}
                                                className="w-full h-48 object-contain bg-gray-100 border-b border-gray-200 p-2"
                                            />
                                            <div className="p-4">
                                                <p className="text-gray-800 font-medium text-base mb-3 truncate">{image.name}</p>
                                                <button
                                                    onClick={() => downloadImage(image)}
                                                    className="w-full px-4 py-3 bg-gradient-to-r from-purple-600 to-indigo-600 text-white font-semibold rounded-lg
                                                               hover:from-purple-700 hover:to-indigo-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2
                                                               transition-all transform hover:scale-105 active:scale-95 text-base shadow-md"
                                                >
                                                    ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                                <div className="text-center mt-8">
                                    <button
                                        onClick={downloadAllImages}
                                        disabled={isZipping}
                                        className={`px-10 py-4 rounded-full text-white font-bold rounded-full shadow-xl
                                                   ${isZipping ? 'bg-gray-400 cursor-not-allowed' : 'bg-gradient-to-r from-indigo-600 to-blue-700 hover:from-indigo-700 hover:to-blue-800 focus:outline-none focus:ring-4 focus:ring-indigo-300 focus:ring-offset-2 transition-all transform hover:scale-105 active:scale-95'} text-xl`}
                                    >
                                        {isZipping ? (
                                            <div className="flex items-center">
                                                <svg className="animate-spin -ml-1 mr-3 h-7 w-7 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                </svg>
                                                ZIPãƒ•ã‚¡ã‚¤ãƒ«ç”Ÿæˆä¸­...
                                            </div>
                                        ) : (
                                            'ã™ã¹ã¦ZIPã§ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰'
                                        )}
                                    </button>
                                </div>
                            </div>
                        )}

                        <p className="text-center text-gray-600 text-sm mt-10 opacity-80">
                            æ³¨: ã“ã®ã‚¢ãƒ—ãƒªã¯ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒã‚¤ãƒ†ã‚£ãƒ–æ©Ÿèƒ½ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ãŸã‚ã€HEICã‚„ä¸€éƒ¨ã®RAWãƒ•ã‚¡ã‚¤ãƒ«ãªã©ã€ãƒ–ãƒ©ã‚¦ã‚¶ãŒç›´æ¥ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ç‰¹æ®Šãªã‚³ãƒ¼ãƒ‡ãƒƒã‚¯ã®å¤‰æ›ã«ã¯å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚
                        </p>
                    </div>
                </div>
            );
        };

        // Render the App component into the root div
        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
